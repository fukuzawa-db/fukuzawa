\documentclass[a4j,twocolumn]{jarticle}
\usepackage{fancybox}
\usepackage[dvipdfm]{graphicx}

\title{ハイブリッドDBシステム解説}
\author{1051090 福澤優}
\date{2011.11}

\begin{document}
\twocolumn
\maketitle

%1ディレクトリに関する情報
\section{ディレクトリ情報}
システムのソースコードや必要なデータはいくつかのディレクトリに分かれて格納されている.
ここでは各ディレクトリの情報を示す.

\subsection{COMMONディレクトリ}
COMMONディレクトリでは様々な演算で用いられる共通のデータ構造体やデータ型，クラスの定義や，
テーブル，属性情報などのシステムカタログを扱うクラスのコードが格納されている.

\subsection{PosValディレクトリ}
演算中で扱うテーブルの各データはデータの値とテーブル中でのポジション（テーブル中の何番目のデータか）の2つで扱われる.
PosValディレクトリではこのデータを扱うためのクラスが各データ型に分かれて定義されている.

\subsection{NSMディレクトリ}
テーブルデータを格納する際に1つのテーブルから行指向データと列指向データの両方を生成する.
ここでは行指向データ生成のためのクラスが定義されている.

\subsection{DSMディレクトリ}
列指向データ生成のためのクラスが定義されている.
列指向データでは圧縮する場合と圧縮しない場合の2パターンのデータを生成できる.
圧縮はランレングス圧縮法によっておこなわれる.

\subsection{InsertOperatorディレクトリ}
データから行指向と列指向データを生成するときに呼び出すクラスが定義されている.
またTPC-Hのベンチマークより行指向と列指向データを生成するスクリプトも格納されている.
ここで生成されたデータはRunDataディレクトリに全て格納される.

\subsection{Operationディレクトリ}
列指向，行指向共通のSQLの演算子クラスが定義されている.
行指向データに対してのSQLのSELECT命令は，このディレクトリにあるクラスを組み合わせて行うことが可能.

\subsection{Operation\_Cディレクトリ}
列指向データ専用の演算子が定義されている.
Operationディレクトリに定義されている演算子を含めて，列指向データまたは行指向と列指向を組み合わせた
データに対してSQLのSELECT命令を実行することが可能となる.

\subsection{Nodeディレクトリ}
選択演算を行う際に用いる演算木を生成する際に各ノードに用いられるクラスが定義されている.

\subsection{Aggregationディレクトリ}
GROUP BY演算で行う集約演算が定義されている.

\subsection{RunDataディレクトリ}
DBシステムで扱うデータの全てが格納されているディレクトリ.
システムカタログ，テーブル情報がBDBデータとして格納されている.

\subsection{TPC-H\_DATAディレクトリ}
実験用データとして用いられるTPC-Hの各テーブルデータがスケール１の大きさで格納されている.
InsertOperatorディレクトリにあるTPC-Hデータ格納のためのスクリプトは，このディレクトリにあるデータを呼び出す.

\subsection{TestOpe*ディレクトリ}
TPC-Hのクエリ8のクエリを段階的に実行するためのプログラムが格納されている.

\subsection{SQLディレクトリ}
TPC-Hのクエリ8のクエリを段階的に実行するためのSQL文が格納されている.

\subsection{Documentディレクトリ}
DBシステムに関するドキュメントを格納するためのディレクトリ.

%2
\section{データ型}			\label{sec:データ型}
システム内で扱うテーブルのデータ型を述べる.
テーブルデータは演算を実行する際に，value(データの値）とposition(データの位置)のセットで扱われるようにPosValディレクトリ内で定義されている.
valueとして扱えるデータ型はCOMMONディレクトリ内の"CommonDataDef.h"で列挙型データDataTypeとして定義されていて，
以下のデータ型が扱える.':'の前に記述してある型がシステムとして扱う型の名前で，後ろにプログラムとして内部的に扱うデータ型を示している。

\begin{itemize}
\item{INT型 : int}
\item{LONG型 : long}
\item{FLOAT型 : float}
\item{DOUBLE型 : double}
\item{FIXED\_TEXT型 : char[dataSize]}
\item{VARIABLE\_TEXT型 : char[dataSize]}
\item{DATE型 : char[10]}
\end{itemize} 

DATE型は$10$文字の文字列として"YYYY-MM-DD"の形式で扱われる.

%3
\section{テーブルの挿入}
システムではテーブル単位でのデータの挿入が可能である.以下はテーブルの格納手順について述べていく.
テーブルの挿入はInsertOperatorディレクトリ内の実行ファイル"main"で行い，実行時にコマンドラインより，格納したいテーブルデータを記述したファイル名を1つ与える.実行ファイルに与えるテーブルデータファイルはレコードデータが1行ごとに記述されており，レコード内の属性データがセパレータ'$\mid$'で区切られている必要がある.レコード数の最大値としては内部的にpositionデータとint型で管理しているためINT\_MAXまでのデータは正常に扱えるはず(?).
実行フィルを実行するとテーブルに関する情報を対話形式で入力する.以下に入力の流れを示す.

\begin{center}
\fbox{
\begin{tabular}{cl}
1. & 挿入テーブル名の入力 \\
2. & 挿入テーブルの属性数の入力 \\ 
3. & 1つの属性名の入力 \\ 
& (以下の入力はここで指定した属性に対して) \\
4. & 属性のデータ型を選択 \\
& (セクション\ref{sec:データ型}で示したものより選択) \\
5. & 属性が主キーかどうか \\
6. & 列指向データ生成時に圧縮データも作成するか \\
7. & データがソートされているかどうか \\
8. & 属性がTEXT型の場合，文字数の上限の入力 \\
9. & 未入力の属性が無くなるまで3から繰り返し \\
\end{tabular}
}
\end{center}


属性情報は，コマンドラインで指定したテーブルデータファイルに記述されている属性順と一致しなければならない.

テーブル情報入力後に，システムカタログの更新とテーブルの行指向データと列指向データが(圧縮データ作成を指定した場合は圧縮データも)作成される.ここで更新・作成したデータはすべてRunDataディレクトリに格納される.

また，InsertOperatorディレクトリ内にはTPC-H\_DATAディレクトリ内に格納されているTPC-Hの各テーブルデータから，自動的に挿入を行うスクリプト("Insert\_*")が用意されている.

%4
\section{システムカタログ}
テーブル挿入時に入力されたデータはシステム内でシステムカタログの情報として，テーブル情報と属性情報に分けてRunDataディレクトリに格納される.

\subsection{テーブル情報}
テーブル情報はシステム内においてはCOMMONディレクトリ内の"CommonDataDef.h"で定義されている以下の構造体で扱われる.ここでのtableIDは各テーブルに挿入順に$1$からユニークに割り当てられるものである.


\begin{verbatim}
typedef struct TABLE_REC_STRUCT{
    unsigned int tableID;
    unsigned int attriNum;
    char tableName[MAX_NAME_LENGTH];
} TABLE_REC;
\end{verbatim}


ユーザから得られたテーブル情報はBerkeleyDBを通してRunDataディレクトリ内の"BDB\_TABLE\_MANEGE\_FILE.db"ファイルとして保存される.
また，この時BerkeleyDBにはキーとしてunsigned int型で扱われるtableIDを渡し，データとしてtableID, attriNum, tableNameを順に記述したものを渡し格納する.さらにテキストデータとして"TABLE\_MANEGE\_FILE"ファイルにもテーブル情報を出力しており1つのテーブル情報を一行ずつtableName,　attriNum, tableIDの順にセパレータ'$\mid$'で区切り記述している.

\subsection{属性情報}
テーブル情報と同様に属性情報もBerkeleyDBを通して管理される.
内部的にはCOMMONディレクトリ内の"CommonDataDef.h"で定義されている以下の構造体で属性情報が扱われる.


\begin{verbatim}
typedef struct ATTRIBUTE_REC_STRUCT{
    char attributeName[MAX_NAME_LENGTH];
    unsigned int tableID;
    unsigned int attributeID;
    DataType dataType;
    unsigned short dataLength;
    bool primary;
    bool isCompress;
    bool isSort;
} ATTRIBUTE_REC;
\end{verbatim}

attributeIDは各テーブル内の個々の属性に対してユニークに$1$から割り当てられる.つまりテーブルが異なれば重複するattributeID存在することもあり得る.
属性情報はBerkeleyDBを通してRunDataディレクトリ内の"BDB\_ATTRIBUTE\_MANEGE\_FILE.db"ファイルとして保存される.この時，格納は1つの属性情報ずつ行われ，キーとしては，unsined int型の上位16bitにtableIDの値，下位16bitにattributeIDの値をセットした値を渡す.これによって扱えるテーブルの上限と，1つのテーブル内で扱える属性の上限はともに$2^{16} = 65536$となる(ただし1つのテーブル内での属性の上限はCOMMONディレクトリ内の"CommonDataDef.h"で定義されているMAX\_ATTRIBUTE\_NUMによって256に制限されている).また，データとしては構造体のメンバーの上から順に格納した情報を渡して格納していく.属性情報も，テーブル情報と同じくテキストデータとしても"ATTRIBUTE\_MANEGE\_FILE”ファイルに記述しており，BerkeleyDBのデータに渡す構造体メンバー順にセパレータ'$\mid$'で区切り格納している.


%5
\section{データの格納方式}
ここではテーブル挿入時にBerkeleyDBを用いてデータがどのように格納されるかを述べていく.

\subsection{BerkeleyDBのチューニング}
データの格納や読み込みはCOMMONディレクトリ内で定義してあるBDBOpeクラスを通じて行われる.
BDBOpeクラスを利用する際，同じディレクトリ内の"CommonDataDef.h"ファイルで定義されている変数を元にチューニングが行われる.
表\ref{tbl:one}にBerkeleyDBの設定の際に用いられるチューニングパラメータを示す.
これらのチューニングパラメータはデータ格納時のみならずSELECTクエリ実行時にも共通で利用される.

\begin{center}
\begin{table}[htbp]
\caption{BerkeleyDBのチューニングパラメータ}
\label{tbl:one}
\begin{tabular}{l|l}
\hline \hline
BDB\_PAGE\_SIZE & BerkeleyDBの \\
& ページサイズ \\ \hline
& BerkeleyDBの \\
BDB\_CACHE\_SIZE\_BYTE & キャッシュサイズ \\
& (byte単位) \\ \hline
& BerkeleyDBの \\
BDB\_CACHE\_SIZE\_GBYTE & キャッシュサイズ \\
& (Gbyte単位) \\ \hline
\end{tabular}
\end{table} 
\end{center}

\subsection{行指向データ}
行指向データの格納方法はBerkeleyDBにレコード単位でデータを渡して格納していく.
この時，キーとしてはレコードのposition情報（取り出したデータ順に$1$からシーケンシャルにposition情報として割り当てる）を渡す.
データは$1$つのレコードデータの情報を渡す.この時VARIABLE\_TEXT型以外のデータ型では，データ長が一定であるためシーケンシャルにデータを領域に格納できる.しかしVARIABLE\_TEXT型は可変長であるため'$\setminus0$'の終端記号を付加して格納している.

ここで作成されたデータはRunDataディレクトリ内に"テーブル名.row"というデータ名で格納される.

\subsection{圧縮なし列指向データ}
列指向データはデータをランレングス圧縮を用いて圧縮する場合のデータと，圧縮しない場合のデータの両方がある.
圧縮なしの列指向データは全ての列データに対して作成される.ここでは圧縮なしの列指向データの格納方法について述べる.

圧縮なし列指向データでは用意されたバッファにテーブルの先頭からデータをシーケンシャルに配置して，バッファが一杯になるか，格納データが無くなった際にBerkeleyDBにデータとしてバッファを渡すという手順で格納していく.バッファはヘッダ情報としてバッファに含まれている列データの数と，バッファに格納されているデータのうち一番先頭に格納されているデータのpositionの2つの情報を，バッファの先頭に格納する.その後ろにテーブルの列データを格納していく.またBerkeleyDBに渡すキーとしてはバッファに格納されたデータの最後のデータのposition情報を渡す.

バッファサイズのチューニングはCOMMONディレクトリ内の"CommonDataDef.h"ファイルで定義されている表\ref{tbl:two}のパラメータで行うことが可能である.

\begin{center}
\begin{table}[htbp]
\caption{列指向データのチューニングパラメータ}
\label{tbl:two}
\begin{center}
\begin{tabular}{l|l}
\hline \hline
DSM\_BUFFER\_SIZE & 列指向データの \\
& バッファサイズ \\ \hline
\end{tabular}
\end{center}
\end{table} 
\end{center}

ここで作成されたデータはRunDataディレクトリ内に"tableID.attributeID.DSM"の形式で名前が付けられ格納される.


\subsection{圧縮あり列指向データ}
圧縮あり列指向データでは圧縮なし列指向データ同様にバッファを利用してデータを格納していく.圧縮あり列指向データにおいては，圧縮率を上げるために，まずデータをソートする必要性がある.ソートによって元のデータからpositionの値が変わってしまうためソート前のposition情報を保存しておく必要性があり，ソート前のposition情報をソート後のデータの順番で圧縮なし列指向データを用いて格納する.このデータはRunDataディレクトリ内に"tableID.attributeID-to-tableID.0.JoinIndex"の形式の名前で格納される.

ソートされたデータはランレングス圧縮を行いながら格納していく.ランレングス圧縮によりデータは(データ内容,重複データのはじめのデータのposition, 繰り返しの回数)というデータ形式になり，圧縮される(positionはソート後の位置情報をセットする.この後の処理もpositionはソート後のもの）.圧縮なし列指向データと同じヘッダ情報をバッファに書き込み，その後ろに圧縮されたデータが順次格納されていく.
ヘッダ情報のてバッファに含まれているデータの数は，圧縮後のデータ形式を1つとして数えていくので，実際に取り出せるデータではないことに注意(デコードすると当然数が多くなる).

バッファに格納されたデータは圧縮なし列指向データ同様にBerkeleyDBに渡されRunDataディレクトリ内に"tableID.attributeID.DSM\_C"として格納される.

また，バッファのサイズは圧縮なし列指向データの場合と同じになる.

%6
\section{SELECTクエリの実行}
格納テーブルデータに対するSELECTクエリはOperationディレクトリとOperation\_Cディレクトリに定義されている演算子を用いて行われる.
ここでは演算子の共通概念を記述していく.

\subsection{Operatiorクラス}
多くの演算子はOperatorクラスを親クラスとして継承している.よってOperatorクラスは演算子の基本となるメソッドが定義されている.
クエリを実行する際には，クエリ木を生成したのちに処理を実行していく.ここでは具体的にクエリ木を生成したあとに行われるOperatorクラスで定義されている共通の処理の流れを述べていく.

まずクエリ木の各ノードの演算子の初期化を行うために，クエリ木のルートノードに初期化を行うinit()メソッドを呼び出す.するとroot以下のノードは図\ref{fig:one}のような流れで同様に初期化が行われる.

\begin{center}
\begin{figure}[htbp]
 \includegraphics[width=7.0cm]{./fig/1.eps}
 \caption{ノード初期化の流れ}
 \label{fig:one}
\end{figure}
\end{center}

図\ref{fig:one}では中心のノードに着目した処理の流れが示されている.あるノードが親ノードからinit()メソッドが呼び出されると，まず自身の子ノードのinit()メソッドを呼び出す.子ノードは演算子によって1つか2つか異なる.その後子ノードのinit()メソッドから戻ってくると，自身のノードのinit()メソッドの処理を行い，init()メソッドの呼び出し元である親ノードに返る.

次に，init()メソッドで行われる処理について述べていく.init()メソッド内で共通に行われる処理を以下に示す.


\begin{center}
\fbox{
\begin{tabular}{cl}
1. & 子ノードinit()の呼び出し \\
2. & getAttriNum()の呼び出し　\\ 
3. & initAttriRec()の呼び出し \\ 
4. & getAttriRec()の呼び出し \\
5. & initPosVal()の呼び出し \\
\end{tabular}
}
\end{center}


まず，先ほど述べたように子ノードのinit()メソッドを読み出す.次にgetAttriNum()メソッドにより子ノードから受け取るデータの属性数を得る.
さらにinitAttriRec()メソッドにより，先ほど得た属性数だけクラス内で保持する属性データ変数を初期化し，getAttriRec()メソッドによって子ノードから得られた属性データを格納する.最後にinitPosVal()によって属性データを参照し，子ノードから得られるタプルデータを格納する領域を初期化する.


全てのノードの初期化が行われる，つまりrootノードのinit()メソッドから戻ったのちにレコードデータに対する処理を行っていく.
この時，ノード共通のメソッドとしてgetRow()メソッドが利用される.getRow()メソッドはinit()メソッドと同様の流れで，子ノードのgetRow()を呼び出し処理に必要なレコードデータを子ノードから受け取り，そのレコードデータに対して必要な処理を行い親ノードへ渡す.子ノードは親ノードへ渡すレコードデータが無くなった場合は戻り値として'-1'を返すことになっている.

%7
\section{Operationディレクトリ内の演算子解説}
ここではOperationディレクトリ内で定義されている演算子を述べていく.

\subsection{Scanクラス}
BerkeleyDBによって格納された行指向データから1行ずつデータを取り出し，親ノードへ値を渡す.
Scanクラスは実行時の葉ノードに位置する.

\subsection{OutPutクラス}
子ノードから得られたデータを標準入力に全て出力する.
ファイル出力や出力制限を設けるような改良が必要.

\subsection{Projectionクラス}
子ノードから得られたレコードデータから指定された属性データだけを取り出し親ノードへ渡す.

\subsection{Selectionクラス}
子ノードから得られたレコードデータから条件に一致するレコードデータのみを親ノードへ渡す.条件の指定はNodeディレクトリ内にあるクラスを用いて演算木を生成してSelectionオブジェクトの生成時に引数として渡すことで行う.

\subsection{Sortクラス}
子ノードから出力される全てのデータを取り出し，指定された属性に対してソートを行う.指定する属性は複数でもよい.
扱うレコードが少ない場合は全てメモリ上にデータを取り込んでクイックソートを行う.しかしデータ量が一定の閾値を越えるとバッファに取り込んだデータに対してソートを行い，ソートされたデータをBerkeleyDBを通して一時ファイルとして格納しておく.データが無くなるまで処理を繰り返し，親ノードにデータを渡す際に全ての一時ファイルをマージソートし，親ノードに値を渡していく.
この，一時ファイルを利用する閾値(workspace)はCOMMONディレクトリ内の"CommonDataDef.h"ファイルで定義されている(表\ref{tbl:three}).

\begin{center}
\begin{table}[htbp]
\caption{Sortクラスのチューニングパラメータ}
\label{tbl:three}
\begin{center}
\begin{tabular}{l|l}
\hline \hline
MAX\_WORK\_SPACE & メモリのworkspace \\ \hline
\end{tabular}
\end{center}
\end{table} 
\end{center}

\subsection{MargeJoinクラス}
MargeJoinクラスではソートされたデータを2つの子ノードから受け取ることを想定して設計されている.
受け取ったデータ同士を指定した属性同士を比較して，一致するレコードデータ同士を結合して親ノードへ渡す.

\subsection{NestedJoinクラス}
2つの子ノードから受け取ったレコードデータから入れ子ループ結合を行うクラス.InnerNodeとして設定された子ノードからのレコードデータは複数のループによって何度のスキャンしなければならないため，始めにInnerNodeからのレコードデータを全てBerkeleyDBを利用して一時ファイルに格納する.その後OuterNodeとして設定された子ノードから１つずつレコードデータを受け取り，一時ファイルをスキャンしながら指定した属性データが一致した場合のみ親ノードに2つのレコードデータを結合したものを渡す.

\subsection{HashJoinクラス}
HashJoinクラスでは2つの子ノードから全てのレコードデータを受け取り，指定した属性同士からそれぞれのデータ集合からハッシュテーブルを作成する.ハッシュテーブルに用いるハッシュキーは指定した属性データから生成する.ハッシュテーブルはBerkeleyDBを通してキーにハッシュ関数で作成されたハッシュキー，データとしてレコードデータを渡し作成される.

ハッシュテーブルが作成された後はハッシュキーをシーケンシャルに辿り，2つのハッシュテーブルを参照して指定した属性同士が一致した場合のみレコード同士を結合して親ノードへ渡す.

ハッシュ関数はOperationディレクトリの"Hash.cpp"ファイル内で定義されている.ハッシュキーはVARIABLE\_TEXT型以外のデータから生成が可能であり，ハッシュテーブルを生成する演算子ではVARIABLE\_TEXT型からハッシュキーを生成するような処理はできない.

ハッシュに関するチューニングパラメータは表\ref{tbl:four}に示す内容で，COMMONディレクトリ内の"CommonDataDef.h"ファイルで定義されている.

\begin{center}
\begin{table}[htbp]
\caption{ハッシュのチューニングパラメータ}
\label{tbl:four}
\begin{center}
\begin{tabular}{l|l}
\hline \hline
HASH\_SIZE & ハッシュテーブルの大きさ \\ \hline
MUL\_NUM & ハッシュキー作成時の乗算値 \\ \hline
\end{tabular}
\end{center}
\end{table} 
\end{center}

\subsection{OneSideHashJoinクラス}
HashJoinクラスとは異なりOneSideHashJoinクラスではハッシュテーブルは1つしか作成しない.InnerNodeとして指定された子ノードに対して，指定した属性からハッシュキーを生成し，BerkeleyDBからハッシュテーブルを作成する.その後，OuterNodeとして指定された子ノードから1つずつレコードデータを取り出し，ハッシュテーブルからハッシュキーが一致するデータを参照し，指定した属性データの値が一致する場合のみ親ノードにデータを渡す.

\subsection{GroupByクラス}
指定した属性データ（複数指定可能）に対してグループ化を行うクラス.
グループ化は，ハッシュ法を用いて行われる.このためソートを行ってからグループ化を行う方法と比べるとデータをソートするコストがかからない.
指定した属性データよりハッシュキーを生成し，指定データの属性値のみをリストを用いたチェインハッシュ法で格納していく.
ハッシュ結合の場合と異なりハッシュテーブルをBerkeleyDBを通して作成せずに，すべてメモリ上で行う実装となっているのでグループ化の対象とするデータ集合のカーディナリティが高い場合にはメモリオーバーフローが起ってしまうことに注意しなければならない.

GROUP BY演算の際に共に行われることが多い集約演算はAggregationディレクトリに定義してあるクラスより演算木を生成し，GroupByクラスに渡すことによって実行が可能である.この集約演算を行う演算木は複数指定も可能となっている.集約演算ではCOUNT,MAX,MIN,SUM,AVGの演算が可能となっており，さらにNodeディレクトリ内のクラスを用いて，集約演算同士のの四則演算などが可能となっている.しかし，SQL文で用いることができる条件を付加した集約演算（条件を満たすレコードデータのみに対して集約演算を行うなど）などの実装は出来ていない.

\subsection{Extractクラス}
ExtractクラスはDATE型のデータに対してのみ行われる.EXTRACT演算によって日付データの年，月，日の中から任意のデータのみを抽出することができる.抽出されなかったデータに対しては'0'が割り当てられるという仕様で実装されている.例えば"1998-05-14"から年のデータのみを抽出すると"1998-00-00"となる.Extractクラスは子ノードから受け取ったレコードデータから指定された属性に対してECXTRACT演算おこない，親ノードへそのレコードデータを渡す.

%8
\section{Operation\_Cディレクトリ内の演算子解説}
Operation\_Cディレクトリには主に列指向データに対する演算子が定義されている.
ここではそれらの演算子クラスについて述べていく.

\subsection{ScanDSMクラス}
このクラスでは非圧縮列指向データに対して行われるスキャン演算である.
一行ずつデータを取り出し，ポジション情報を付加させて親ノードへデータを渡す.

\subsection{ScanRLEクラス}
ScanRLEクラスは圧縮列指向データに対するスキャン演算子となっている.
ScanDSMクラスと異なる箇所は，圧縮データを生成する際に同時に作成した元のポジション情報データを参照して，そこからデータに対するポジション情報を付加させて親ノードへ渡す点である.

\subsection{SelectBitクラス}
SelectBitクラスではSelectクラス同様に条件に一致するレコードを抽出することである.しかし，SelectBitクラスでは親ノードに渡すデータとしてレコードデータを渡すのではなく，各レコードが条件に一致するかどうかを'0'と'1'で表したビットマップデータを１つずつ渡す仕様になっている.
子ノードからレコードデータを受け取り，条件に照らしあせて条件に一致するレコードであれば'1'を，そうでなければ'0'をそれぞれ親ノードへと渡していく.選択条件の演算木などはSelectクラスと同じように扱う.

\subsection{BitSortクラス}
もし圧縮データに対してSelectBitクラスの演算を実行した際にビットマップデータとして出力されるデータの順番はソート後のデータ順になっている.しかし，圧縮していないデータとのポジションの整合性を取ろうとしたときに，このビットマップの出力順をソート前のデータ順で出力する必要性が出てくる.このビットマップの並び替えを行うのがBitSortクラスである.BitSortクラスは圧縮列指向データ生成時に作成した"tableID.attributeID-to-tableID.0.JoinIndex"形式のデータを参照しながら，SelectBitクラスから渡されるビットマップをソート前の順番で親ノードへと渡す.

現在，BitSortクラスでは必ずファイルを通じてビットマップの並び替えを行っているが，データが小さい場合は全てメモリ上で並び替えを行う仕様に改良する必要がある.

\subsection{BitFilterクラス}
BitFilterクラスでは指定したレコードデータとビットマップを出力する２つの子ノードから，ビットマップに一致するデータを出力する演算子である.
このことより，1つの子ノードとしてSelectBitクラスかBitSortクラスを設定しなければならない，また他の条件としては子ノードから受け取るレコードデータとビットマップのデータのポジション情報が一致しなければならなく，さらにデータ数も同一でなければならない.

ビットマップデータとして'1'を受け取った場合に限り，一致するレコードデータを親ノードへと渡す.

\subsection{JoinIndex\_OneHashクラス}
JoinIndex\_OneHashクラスは2つのレコードデータからJoin演算を行う演算子である.アルゴリズムとしてはOneSideHashJoinクラスと同様に処理されるが，JoinIndex\_OneHashクラスでは出力される値としてレコードデータが出力されるが，レコードデータの各属性のポジションデータを対応みるとJoinIndexデータとしても扱えるという出力になっている.

現在JoinIndex\_OneHashクラスではハッシュテーブルを作成するInnerNodeからの受け取るデータとしては1属性しか持たないレコードデータと仮定して設計されている（複数レコードでも動作はするが，Join条件のレコード属性以外のポジション情報が維持されない仕様になっている）.

\subsection{ScanFromJIクラス}
outerNodeとして設定した子ノードのレコードデータのうちから指定された属性データのポジション情報と，innerNodeとして渡されるデータのレコードデータのポジション情報同士を比較して，一致するレコードデータ同士を結合して親ノードへ渡す.

制約としては，innerNode,outerNodeの両方から受けとるデータの順はポジションに対してソートされていなければならない.つまり，ポジションに対するマージ結合を行うような実装となっている.

また，innerNodeから受け取るレコードデータは1属性のみと仮定して実装されている（複数属性でもよいが，ポジションを参照する属性はレコードの1番目の属性となる）.

\subsection{ScanFromJI\_OneHashクラス}
ScanFromJIクラスではポジションに対してマージ結合を行うため，レコードデータが注目される属性データのポジションに対してソートされていなければならないという制約が存在した.この制約が無くてもポジション情報同士を比較する結合ができる演算子がScanFromJI\_OneHashクラスである.

OneSideHashJoinクラスと同様にinnerNode側に対してのみハッシュテーブルを作成し，結合を行っていく．ただし，このときはポジション情報からハッシュキーが生成される.

これによって，ポジション情報に対してソートされていないレコードデータ同士を結合することが可能となる.


\end{document}
